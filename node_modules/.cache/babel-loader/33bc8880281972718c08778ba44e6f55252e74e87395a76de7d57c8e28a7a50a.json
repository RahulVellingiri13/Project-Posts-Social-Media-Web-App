{"ast":null,"code":"// import { createSlice, nanoid, createAsyncThunk } from \"@reduxjs/toolkit\";\n// import { sub } from \"date-fns\";\n// import axios from \"axios\";\n\n// const POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\n// // const initialState = [\n// //   {\n// //     id: \"1\",\n// //     title: \"Macbook\",\n// //     content: \"It is hard\",\n// //     date: sub(new Date(), { minutes: 10 }).toISOString(),\n// //     reactions: {\n// //       thumbsUp: 0,\n// //       wow: 0,\n// //       heart: 0,\n// //       rocket: 0,\n// //       coffee: 0,\n// //     },\n// //   },\n// //   {\n// //     id: \"2\",\n// //     title: \"Windows\",\n// //     content: \"It is Easy\",\n// //     date: sub(new Date(), { minutes: 5 }).toISOString(),\n// //     reactions: {\n// //         thumbsUp: 0,\n// //         wow: 0,\n// //         heart: 0,\n// //         rocket: 0,\n// //         coffee: 0,\n// //       },\n// //   },\n// // ];\n\n// //rewriting the initial state so that we can fetch the data from the apis\n\n// const initialState = {\n//   posts: [],\n//   status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n//   error: null,\n// };\n\n// export const fetchPosts = createAsyncThunk(\"posts/fetchPosts\", async () => {\n//   const response = await axios.get(POSTS_URL);\n//   return response.data;\n// });\n\n// const postsSlice = createSlice({\n//   name: 'posts',\n//   initialState,\n//   reducers: {\n//     // postAdded(state,action){\n//     //     state.push(action.payload)\n//     // }\n//     //rewriting the code her for updating the structure of the data\n//     postAdded: {\n//       reducer(state, action) {\n//         state.posts.push(action.payload);\n//       },\n//       //using 'prepare' callback here for maintaining the data structure\n//       prepare(title, content, userId) {\n//         return {\n//           payload: {\n//             id: nanoid(),\n//             title,\n//             content,\n//             date: new Date().toISOString(),\n//             userId,\n//             reactions: {\n//               thumbsUp: 0,\n//               wow: 0,\n//               heart: 0,\n//               rocket: 0,\n//               coffee: 0,\n//             },\n//           },\n//         };\n//       },\n//     },\n\n//     reactionAdded(state, action) {\n//       const { postId, reaction } = action.payload;\n//       const existingPost = state.posts.find((post) => post.id === postId);\n//       if (existingPost) {\n//         existingPost.reactions[reaction]++;\n//       }\n//     },\n//     extraReducers(builder) {\n//       builder\n//         .addCase(fetchPosts.pending, (state, action) => {\n//           state.status = \"loading\";\n//         })\n//         .addCase(fetchPosts.fulfilled, (state, action) => {\n//           state.status = \"succeeded\";\n//           //Adding date and reactions , because the status is succeded\n//           let min = 1;\n//           const loadedPosts = action.payload.map((post) => {\n//             post.date = sub(new Date(), { minutes: min++ }).toISOString();\n//             post.reactions = {\n//               thumbsUp: 0,\n//               wow: 0,\n//               heart: 0,\n//               rocket: 0,\n//               coffee: 0,\n//             };\n\n//             return post;\n//           });\n//           // Add any fetched posts to the array\n//           state.posts = state.posts.concat(loadedPosts);\n//         })\n//         .addCase(fetchPosts.rejected, (state, action) => {\n//           state.status = 'failed';\n//           state.error = action.error.message\n//         });\n//     },\n//   },\n// });\n\n// //creating and exporting selectAllPosts , so that we can export the changes in it dynamically\n// export const selectAllPosts = (state) => state.posts.posts;\n\n// export const getPostsStatus = (state)=>state.posts.status;\n\n// export const getPostsError = (state) => state.posts.error;\n\n// export const { postAdded, reactionAdded } = postsSlice.actions;\n\n// export default postsSlice.reducer;\n\n//---------------------------------\n\nimport { createSlice, createAsyncThunk, createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport { sub } from 'date-fns';\nimport axios from \"axios\";\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n});\nconst initialState = postsAdapter.getInitialState({\n  status: 'idle',\n  //'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null,\n  count: 0\n});\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await axios.get(POSTS_URL);\n  return response.data;\n});\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async initialPost => {\n  const response = await axios.post(POSTS_URL, initialPost);\n  return response.data;\n});\nexport const updatePost = createAsyncThunk('posts/updatePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  // try-catch block only for development/testing with fake API\n  // otherwise, remove try-catch and add updatePost.rejected case\n  try {\n    const response = await axios.put(`${POSTS_URL}/${id}`, initialPost);\n    return response.data;\n  } catch (err) {\n    //return err.message;\n    return initialPost; // only for testing Redux!\n  }\n});\nexport const deletePost = createAsyncThunk('posts/deletePost', async initialPost => {\n  const {\n    id\n  } = initialPost;\n  const response = await axios.delete(`${POSTS_URL}/${id}`);\n  if ((response === null || response === void 0 ? void 0 : response.status) === 200) return initialPost;\n  return `${response === null || response === void 0 ? void 0 : response.status}: ${response === null || response === void 0 ? void 0 : response.statusText}`;\n});\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    reactionAdded(state, action) {\n      const {\n        postId,\n        reaction\n      } = action.payload;\n      const existingPost = state.entities[postId];\n      if (existingPost) {\n        existingPost.reactions[reaction]++;\n      }\n    },\n    increaseCount(state, action) {\n      state.count = state.count + 1;\n    }\n  },\n  extraReducers(builder) {\n    builder.addCase(fetchPosts.pending, (state, action) => {\n      state.status = 'loading';\n    }).addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      // Adding date and reactions\n      let min = 1;\n      const loadedPosts = action.payload.map(post => {\n        post.date = sub(new Date(), {\n          minutes: min++\n        }).toISOString();\n        post.reactions = {\n          thumbsUp: 0,\n          wow: 0,\n          heart: 0,\n          rocket: 0,\n          coffee: 0\n        };\n        return post;\n      });\n\n      // Add any fetched posts to the array\n      postsAdapter.upsertMany(state, loadedPosts);\n    }).addCase(fetchPosts.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    }).addCase(addNewPost.fulfilled, (state, action) => {\n      // Fix for API post IDs:\n      // Creating sortedPosts & assigning the id \n      // would be not be needed if the fake API \n      // returned accurate new post IDs\n\n      action.payload.id = state.ids[state.ids.length - 1] + 1;\n      // End fix for fake API post IDs \n\n      action.payload.userId = Number(action.payload.userId);\n      action.payload.date = new Date().toISOString();\n      action.payload.reactions = {\n        thumbsUp: 0,\n        wow: 0,\n        heart: 0,\n        rocket: 0,\n        coffee: 0\n      };\n      console.log(action.payload);\n      postsAdapter.addOne(state, action.payload);\n    }).addCase(updatePost.fulfilled, (state, action) => {\n      var _action$payload;\n      if (!((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.id)) {\n        console.log('Update could not complete');\n        console.log(action.payload);\n        return;\n      }\n      action.payload.date = new Date().toISOString();\n      postsAdapter.upsertOne(state, action.payload);\n    }).addCase(deletePost.fulfilled, (state, action) => {\n      var _action$payload2;\n      if (!((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.id)) {\n        console.log('Delete could not complete');\n        console.log(action.payload);\n        return;\n      }\n      const {\n        id\n      } = action.payload;\n      postsAdapter.removeOne(state, id);\n    });\n  }\n});\n\n//getSelectors creates these selectors and we rename them with aliases using destructuring\nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n  // Pass in a selector that returns the posts slice of state\n} = postsAdapter.getSelectors(state => state.posts);\nexport const getPostsStatus = state => state.posts.status;\nexport const getPostsError = state => state.posts.error;\nexport const getCount = state => state.posts.count;\nexport const selectPostsByUser = createSelector([selectAllPosts, (state, userId) => userId], (posts, userId) => posts.filter(post => post.userId === userId));\nexport const {\n  increaseCount,\n  reactionAdded\n} = postsSlice.actions;\nexport default postsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","createSelector","createEntityAdapter","sub","axios","POSTS_URL","postsAdapter","sortComparer","a","b","date","localeCompare","initialState","getInitialState","status","error","count","fetchPosts","response","get","data","addNewPost","initialPost","post","updatePost","id","put","err","deletePost","delete","statusText","postsSlice","name","reducers","reactionAdded","state","action","postId","reaction","payload","existingPost","entities","reactions","increaseCount","extraReducers","builder","addCase","pending","fulfilled","min","loadedPosts","map","Date","minutes","toISOString","thumbsUp","wow","heart","rocket","coffee","upsertMany","rejected","message","ids","length","userId","Number","console","log","addOne","_action$payload","upsertOne","_action$payload2","removeOne","selectAll","selectAllPosts","selectById","selectPostById","selectIds","selectPostIds","getSelectors","posts","getPostsStatus","getPostsError","getCount","selectPostsByUser","filter","actions","reducer"],"sources":["/Users/rahul/Documents/GT/React/redux/reduxyt/src/app/features/posts/postsSlice.js"],"sourcesContent":["// import { createSlice, nanoid, createAsyncThunk } from \"@reduxjs/toolkit\";\n// import { sub } from \"date-fns\";\n// import axios from \"axios\";\n\n// const POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\n// // const initialState = [\n// //   {\n// //     id: \"1\",\n// //     title: \"Macbook\",\n// //     content: \"It is hard\",\n// //     date: sub(new Date(), { minutes: 10 }).toISOString(),\n// //     reactions: {\n// //       thumbsUp: 0,\n// //       wow: 0,\n// //       heart: 0,\n// //       rocket: 0,\n// //       coffee: 0,\n// //     },\n// //   },\n// //   {\n// //     id: \"2\",\n// //     title: \"Windows\",\n// //     content: \"It is Easy\",\n// //     date: sub(new Date(), { minutes: 5 }).toISOString(),\n// //     reactions: {\n// //         thumbsUp: 0,\n// //         wow: 0,\n// //         heart: 0,\n// //         rocket: 0,\n// //         coffee: 0,\n// //       },\n// //   },\n// // ];\n\n// //rewriting the initial state so that we can fetch the data from the apis\n\n// const initialState = {\n//   posts: [],\n//   status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n//   error: null,\n// };\n\n// export const fetchPosts = createAsyncThunk(\"posts/fetchPosts\", async () => {\n//   const response = await axios.get(POSTS_URL);\n//   return response.data;\n// });\n\n// const postsSlice = createSlice({\n//   name: 'posts',\n//   initialState,\n//   reducers: {\n//     // postAdded(state,action){\n//     //     state.push(action.payload)\n//     // }\n//     //rewriting the code her for updating the structure of the data\n//     postAdded: {\n//       reducer(state, action) {\n//         state.posts.push(action.payload);\n//       },\n//       //using 'prepare' callback here for maintaining the data structure\n//       prepare(title, content, userId) {\n//         return {\n//           payload: {\n//             id: nanoid(),\n//             title,\n//             content,\n//             date: new Date().toISOString(),\n//             userId,\n//             reactions: {\n//               thumbsUp: 0,\n//               wow: 0,\n//               heart: 0,\n//               rocket: 0,\n//               coffee: 0,\n//             },\n//           },\n//         };\n//       },\n//     },\n\n//     reactionAdded(state, action) {\n//       const { postId, reaction } = action.payload;\n//       const existingPost = state.posts.find((post) => post.id === postId);\n//       if (existingPost) {\n//         existingPost.reactions[reaction]++;\n//       }\n//     },\n//     extraReducers(builder) {\n//       builder\n//         .addCase(fetchPosts.pending, (state, action) => {\n//           state.status = \"loading\";\n//         })\n//         .addCase(fetchPosts.fulfilled, (state, action) => {\n//           state.status = \"succeeded\";\n//           //Adding date and reactions , because the status is succeded\n//           let min = 1;\n//           const loadedPosts = action.payload.map((post) => {\n//             post.date = sub(new Date(), { minutes: min++ }).toISOString();\n//             post.reactions = {\n//               thumbsUp: 0,\n//               wow: 0,\n//               heart: 0,\n//               rocket: 0,\n//               coffee: 0,\n//             };\n\n//             return post;\n//           });\n//           // Add any fetched posts to the array\n//           state.posts = state.posts.concat(loadedPosts);\n//         })\n//         .addCase(fetchPosts.rejected, (state, action) => {\n//           state.status = 'failed';\n//           state.error = action.error.message\n//         });\n//     },\n//   },\n// });\n\n// //creating and exporting selectAllPosts , so that we can export the changes in it dynamically\n// export const selectAllPosts = (state) => state.posts.posts;\n\n// export const getPostsStatus = (state)=>state.posts.status;\n\n// export const getPostsError = (state) => state.posts.error;\n\n// export const { postAdded, reactionAdded } = postsSlice.actions;\n\n// export default postsSlice.reducer;\n\n//---------------------------------\n\nimport {\n    createSlice,\n    createAsyncThunk,\n    createSelector,\n    createEntityAdapter\n} from \"@reduxjs/toolkit\";\nimport { sub } from 'date-fns';\nimport axios from \"axios\";\n\nconst POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';\n\nconst postsAdapter = createEntityAdapter({\n    sortComparer: (a, b) => b.date.localeCompare(a.date)\n})\n\nconst initialState = postsAdapter.getInitialState({\n    status: 'idle', //'idle' | 'loading' | 'succeeded' | 'failed'\n    error: null,\n    count: 0\n})\n\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n    const response = await axios.get(POSTS_URL)\n    return response.data\n})\n\nexport const addNewPost = createAsyncThunk('posts/addNewPost', async (initialPost) => {\n    const response = await axios.post(POSTS_URL, initialPost)\n    return response.data\n})\n\nexport const updatePost = createAsyncThunk('posts/updatePost', async (initialPost) => {\n    const { id } = initialPost;\n    // try-catch block only for development/testing with fake API\n    // otherwise, remove try-catch and add updatePost.rejected case\n    try {\n        const response = await axios.put(`${POSTS_URL}/${id}`, initialPost)\n        return response.data\n    } catch (err) {\n        //return err.message;\n        return initialPost; // only for testing Redux!\n    }\n})\n\nexport const deletePost = createAsyncThunk('posts/deletePost', async (initialPost) => {\n    const { id } = initialPost;\n\n    const response = await axios.delete(`${POSTS_URL}/${id}`)\n    if (response?.status === 200) return initialPost;\n    return `${response?.status}: ${response?.statusText}`;\n})\n\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState,\n    reducers: {\n        reactionAdded(state, action) {\n            const { postId, reaction } = action.payload\n            const existingPost = state.entities[postId]\n            if (existingPost) {\n                existingPost.reactions[reaction]++\n            }\n        },\n        increaseCount(state, action) {\n            state.count = state.count + 1\n        }\n    },\n    extraReducers(builder) {\n        builder\n            .addCase(fetchPosts.pending, (state, action) => {\n                state.status = 'loading'\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) => {\n                state.status = 'succeeded'\n                // Adding date and reactions\n                let min = 1;\n                const loadedPosts = action.payload.map(post => {\n                    post.date = sub(new Date(), { minutes: min++ }).toISOString();\n                    post.reactions = {\n                        thumbsUp: 0,\n                        wow: 0,\n                        heart: 0,\n                        rocket: 0,\n                        coffee: 0\n                    }\n                    return post;\n                });\n\n                // Add any fetched posts to the array\n                postsAdapter.upsertMany(state, loadedPosts)\n            })\n            .addCase(fetchPosts.rejected, (state, action) => {\n                state.status = 'failed'\n                state.error = action.error.message\n            })\n            .addCase(addNewPost.fulfilled, (state, action) => {\n                // Fix for API post IDs:\n                // Creating sortedPosts & assigning the id \n                // would be not be needed if the fake API \n                // returned accurate new post IDs\n\n                action.payload.id = state.ids[state.ids.length - 1] + 1\n                // End fix for fake API post IDs \n\n                action.payload.userId = Number(action.payload.userId)\n                action.payload.date = new Date().toISOString();\n                action.payload.reactions = {\n                    thumbsUp: 0,\n                    wow: 0,\n                    heart: 0,\n                    rocket: 0,\n                    coffee: 0\n                }\n                console.log(action.payload)\n                postsAdapter.addOne(state, action.payload)\n            })\n            .addCase(updatePost.fulfilled, (state, action) => {\n                if (!action.payload?.id) {\n                    console.log('Update could not complete')\n                    console.log(action.payload)\n                    return;\n                }\n                action.payload.date = new Date().toISOString();\n                postsAdapter.upsertOne(state, action.payload)\n            })\n            .addCase(deletePost.fulfilled, (state, action) => {\n                if (!action.payload?.id) {\n                    console.log('Delete could not complete')\n                    console.log(action.payload)\n                    return;\n                }\n                const { id } = action.payload;\n                postsAdapter.removeOne(state, id)\n            })\n    }\n})\n\n//getSelectors creates these selectors and we rename them with aliases using destructuring\nexport const {\n    selectAll: selectAllPosts,\n    selectById: selectPostById,\n    selectIds: selectPostIds\n    // Pass in a selector that returns the posts slice of state\n} = postsAdapter.getSelectors(state => state.posts)\n\n\nexport const getPostsStatus = (state) => state.posts.status;\nexport const getPostsError = (state) => state.posts.error;\nexport const getCount = (state) => state.posts.count;\n\nexport const selectPostsByUser = createSelector(\n    [selectAllPosts, (state, userId) => userId],\n    (posts, userId) => posts.filter(post => post.userId === userId)\n)\n\nexport const { increaseCount, reactionAdded } = postsSlice.actions\n\nexport default postsSlice.reducer"],"mappings":"AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SACIA,WAAW,EACXC,gBAAgB,EAChBC,cAAc,EACdC,mBAAmB,QAChB,kBAAkB;AACzB,SAASC,GAAG,QAAQ,UAAU;AAC9B,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,SAAS,GAAG,4CAA4C;AAE9D,MAAMC,YAAY,GAAGJ,mBAAmB,CAAC;EACrCK,YAAY,EAAEA,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACC,IAAI,CAACC,aAAa,CAACH,CAAC,CAACE,IAAI;AACvD,CAAC,CAAC;AAEF,MAAME,YAAY,GAAGN,YAAY,CAACO,eAAe,CAAC;EAC9CC,MAAM,EAAE,MAAM;EAAE;EAChBC,KAAK,EAAE,IAAI;EACXC,KAAK,EAAE;AACX,CAAC,CAAC;AAEF,OAAO,MAAMC,UAAU,GAAGjB,gBAAgB,CAAC,kBAAkB,EAAE,YAAY;EACvE,MAAMkB,QAAQ,GAAG,MAAMd,KAAK,CAACe,GAAG,CAACd,SAAS,CAAC;EAC3C,OAAOa,QAAQ,CAACE,IAAI;AACxB,CAAC,CAAC;AAEF,OAAO,MAAM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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}